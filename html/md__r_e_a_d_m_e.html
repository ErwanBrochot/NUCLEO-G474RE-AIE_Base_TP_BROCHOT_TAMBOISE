<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asservissement MCC: TP Commande Numérique Directe</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Asservissement MCC
   </div>
   <div id="projectbrief">Asservissement Courant/Vitesse d&#39;une MCC</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP Commande Numérique Directe </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Ce code à pour but de commander une MCC en courant et en vitesse grâce à 2 correcteurs PI.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Composants utilisés</h2>
<ul>
<li>Nucléo G474-RE</li>
<li>Power Module dsPICDEM</li>
<li>MCC 48V/12A</li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
Objectifs</h2>
<ul>
<li>Réaliser un shell pour commander le hacheur, sur la base d'un code fourni.</li>
<li>Réaliser la commande des 4 transistors du hacheur en commande complémentaire décalée.</li>
<li>Faire l'acquisition des différents capteurs.</li>
<li>Réaliser l'asservissement en temps réel.</li>
</ul>
<h1><a class="anchor" id="autotoc_md25"></a>
Commande MCC Basique</h1>
<ul>
<li>Générer 4 PWM en complémentaire décalée pour contrôler en boucle ouverte le moteur en respectant le cahier des charges,</li>
<li>Inclure le temps mort,</li>
<li>Vérifier les signaux de commande à l'oscilloscope,</li>
<li>Prendre en main le hacheur,</li>
<li>Câbler correctement la STM32 au hacheur</li>
<li>Générer le signal de commande "start" en fonction de la datasheet</li>
<li>Faire un premier essai de commande moteur</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
Generation de 4 PWM</h2>
<p >Générer quatre PWM à partir du Timer 1 pour controler le hacheur.</p>
<p >Cahier des charges :</p><ul>
<li>Fréquence de la PWM : 16kHz</li>
<li>Temps mort minimum : 2us</li>
<li>Résolution minimum : 10bits.</li>
</ul>
<h3><a class="anchor" id="autotoc_md27"></a>
Reglage du Timer 1</h3>
<p >L'horloge du système est de 170 MHz et on souhaite un timer d'une fréquence de 16 kHz. On va donc avoir un ARR=170x10^6/16x10^3-1=10624. Comme le Timer est réglé en center align, on divise cette valeur par 2 ce qui fait que ARR=5311.</p>
<h4><a class="anchor" id="autotoc_md28"></a>
Counter setting</h4>
<p ><img src="./Images/TIM1_param.png" alt="Counter setting" title="Counter setting" class="inline"/></p>
<h4><a class="anchor" id="autotoc_md29"></a>
Deadtime setting</h4>
<p ><img src="./Images/TIM_DeadTime.png" alt="Dead time" title="deadtime setting" class="inline"/></p>
<h4><a class="anchor" id="autotoc_md30"></a>
PWM setting</h4>
<p ><img src="./Images/TIM1_PWM.png" alt="PWM setting" title="PWM setting" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md31"></a>
Observation a l'oscilloscope</h3>
<h4><a class="anchor" id="autotoc_md32"></a>
Observations</h4>
<p ><img src="./Images/Oscillo_PWM.png" alt="Oscillo PWM" title="PWM affichés à l&apos;oscilloscope" class="inline"/></p>
<p >Nos PWM sont bien a 16KHz et complémentaires.</p>
<p ><img src="./Images/Oscillo_temps_mort.png" alt="Oscillo DeadTime" title="Temps mort" class="inline"/></p>
<p >Il y'as bien un temps mort de 2us entre chaques commutations.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Prise en main de hacheur</h2>
<p >Ce hacheur comporte 3 bras de ponts, nous n'en utiliserons que 2 pour commander notre MCC. Nous avons décidé de prendre les bras Yellow et Red car ils sont tout deux munis de capteur a effet Hall contrairement au troisième bras de pont.</p>
<p >En suivant la datasheet du hacheur et les pins utilisés sur notre Nucléo. Nous avons établi les connections de telle manière:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Signal   </th><th class="markdownTableHeadNone">Pin STM32   </th><th class="markdownTableHeadNone">Pin hacheur   </th><th class="markdownTableHeadNone">Correspondance hacheur    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TIM1_CH1   </td><td class="markdownTableBodyNone">PA8   </td><td class="markdownTableBodyNone">Pin 12   </td><td class="markdownTableBodyNone">CM_Y_TOP    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TIM1_CH1N   </td><td class="markdownTableBodyNone">PA11   </td><td class="markdownTableBodyNone">Pin 30   </td><td class="markdownTableBodyNone">CM_Y_BOT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TIM1_CH2   </td><td class="markdownTableBodyNone">PA9   </td><td class="markdownTableBodyNone">Pin 13   </td><td class="markdownTableBodyNone">CM_R_TOP    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TIM1_CH2N   </td><td class="markdownTableBodyNone">PA12   </td><td class="markdownTableBodyNone">Pin 31   </td><td class="markdownTableBodyNone">CM_R_BOT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ISO_RESET   </td><td class="markdownTableBodyNone">PC3   </td><td class="markdownTableBodyNone">Pin 33   </td><td class="markdownTableBodyNone">ISO_RESET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADC1_IN1   </td><td class="markdownTableBodyNone">PA0   </td><td class="markdownTableBodyNone">Pin 16   </td><td class="markdownTableBodyNone">Y_HALL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TIM3_CH1   </td><td class="markdownTableBodyNone">PA6   </td><td class="markdownTableBodyNone">Voie A   </td><td class="markdownTableBodyNone">CODEUR VOIE A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TIM3_CH2   </td><td class="markdownTableBodyNone">PA4   </td><td class="markdownTableBodyNone">Voie B   </td><td class="markdownTableBodyNone">CODEUR VOIE B   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md34"></a>
Commande powerOn</h2>
<p >En s'appuyant sur la datasheet, nous avons codé une fonction qui permet d'intialiser le hacheur en envoyant une impulsion d' au moins 2us. Cette fonction se lance si on entre "power on" dans le Shell ou si on appuie sur le bouton bleu de la Nucleo.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Detail de la fonction</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> motorPowerOn(<span class="keywordtype">void</span>){</div>
<div class="line">    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); <span class="comment">// just for test, you can delete it</span></div>
<div class="line">    <span class="comment">//Phase de démarage//</span></div>
<div class="line">    HAL_GPIO_WritePin(ISO_RESET_GPIO_Port, ISO_RESET_Pin,GPIO_PIN_SET );</div>
<div class="line">    setAlpha(50);</div>
<div class="line">    HAL_TIM_PWM_Start(&amp;htim1,<a class="code hl_define" href="group___t_i_m___channel.html#ga6b1541e4a49d62610899e24bf23f4879">TIM_CHANNEL_1</a> );</div>
<div class="line">    HAL_TIMEx_PWMN_Start(&amp;htim1, <a class="code hl_define" href="group___t_i_m___channel.html#ga6b1541e4a49d62610899e24bf23f4879">TIM_CHANNEL_1</a>);</div>
<div class="line">    HAL_TIM_PWM_Start(&amp;htim1,<a class="code hl_define" href="group___t_i_m___channel.html#ga33e02d43345a7ac5886f01b39e4f7ccd">TIM_CHANNEL_2</a> );</div>
<div class="line">    HAL_TIMEx_PWMN_Start(&amp;htim1, <a class="code hl_define" href="group___t_i_m___channel.html#ga33e02d43345a7ac5886f01b39e4f7ccd">TIM_CHANNEL_2</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> i=0;</div>
<div class="line">    <span class="keywordflow">while</span> (i&lt;33)</div>
<div class="line">    {</div>
<div class="line">        i++;</div>
<div class="line">    }</div>
<div class="line">    HAL_GPIO_WritePin(ISO_RESET_GPIO_Port, ISO_RESET_Pin, GPIO_PIN_RESET);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup___t_i_m___channel_html_ga33e02d43345a7ac5886f01b39e4f7ccd"><div class="ttname"><a href="group___t_i_m___channel.html#ga33e02d43345a7ac5886f01b39e4f7ccd">TIM_CHANNEL_2</a></div><div class="ttdeci">#define TIM_CHANNEL_2</div><div class="ttdef"><b>Definition:</b> stm32g4xx_hal_tim.h:815</div></div>
<div class="ttc" id="agroup___t_i_m___channel_html_ga6b1541e4a49d62610899e24bf23f4879"><div class="ttname"><a href="group___t_i_m___channel.html#ga6b1541e4a49d62610899e24bf23f4879">TIM_CHANNEL_1</a></div><div class="ttdeci">#define TIM_CHANNEL_1</div><div class="ttdef"><b>Definition:</b> stm32g4xx_hal_tim.h:814</div></div>
</div><!-- fragment --><p >Cette fonction commence par mettre le port de ISO_RESET a 1, elle va ensuite initialiser le Timer1 et enfin elle va tourner 34 fois dans une boucle ce qui représente environ 2us avant de remmtre le port ISO_RESET à 0.</p>
<p >Afin d'entrer dans cette fonctions grâce à l'appuie sur le bouton bleu, nous traitons les interruptions venant des GPIO:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group___g_p_i_o___exported___functions___group2.html#ga0cd91fd3a9608559c2a87a8ba6cba55f">HAL_GPIO_EXTI_Callback</a>(uint16_t GPIO_Pin)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (GPIO_Pin== BUTTON_Pin)</div>
<div class="line">    {</div>
<div class="line">        motorPowerOn();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup___g_p_i_o___exported___functions___group2_html_ga0cd91fd3a9608559c2a87a8ba6cba55f"><div class="ttname"><a href="group___g_p_i_o___exported___functions___group2.html#ga0cd91fd3a9608559c2a87a8ba6cba55f">HAL_GPIO_EXTI_Callback</a></div><div class="ttdeci">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</div><div class="ttdoc">Use the interruption on the blue Button to lunch the power module according to the datasheet.</div><div class="ttdef"><b>Definition:</b> main.c:237</div></div>
</div><!-- fragment --><p >Pour entrer dans la fonction en utilisant le commandShell, nous avons modifié la fonction shellExec pour que la commande power on nous fasse entrer dans motorPowerOn:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> shellExec(<span class="keywordtype">void</span>){</div>
<div class="line">    <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;set&quot;</span>)==0){</div>
<div class="line">        <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;PA5&quot;</span>)==0 &amp;&amp; ((strcmp(argv[2],<span class="stringliteral">&quot;0&quot;</span>)==0)||(strcmp(argv[2],<span class="stringliteral">&quot;1&quot;</span>)==0)) ){</div>
<div class="line">            HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, atoi(argv[2]));</div>
<div class="line">            stringSize = snprintf((<span class="keywordtype">char</span>*)uartTxBuffer,UART_TX_BUFFER_SIZE,<span class="stringliteral">&quot;Switch on/off led : %d\r\n&quot;</span>,atoi(argv[2]));</div>
<div class="line">            HAL_UART_Transmit(&amp;huart2, uartTxBuffer, stringSize, HAL_MAX_DELAY);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;speed&quot;</span>)==0){</div>
<div class="line">            <span class="keywordflow">if</span>(atoi(argv[2])==0 &amp;&amp; strcmp(argv[2],<span class="stringliteral">&quot;0&quot;</span>)!=0){</div>
<div class="line">                HAL_UART_Transmit(&amp;huart2, motorSpeedInst, <span class="keyword">sizeof</span>(motorSpeedInst), HAL_MAX_DELAY);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span>{</div>
<div class="line">                motorSetSpeed(atoi(argv[2]));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;alpha&quot;</span>)==0){</div>
<div class="line">            setAlpha(atoi(argv[2]));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;current&quot;</span>)==0){</div>
<div class="line">                    consignCurrent=(atof(argv[2]));</div>
<div class="line"> </div>
<div class="line">                }</div>
<div class="line">        <span class="keywordflow">else</span>{</div>
<div class="line">            shellCmdNotFound();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;help&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, help, <span class="keyword">sizeof</span>(help), HAL_MAX_DELAY);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;pinout&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, pinout, <span class="keyword">sizeof</span>(pinout), HAL_MAX_DELAY);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((strcmp(argv[0],<span class="stringliteral">&quot;power&quot;</span>)==0)&amp;&amp;(strcmp(argv[1],<span class="stringliteral">&quot;on&quot;</span>)==0))</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, powerOn, <span class="keyword">sizeof</span>(powerOn), HAL_MAX_DELAY);</div>
<div class="line">        motorPowerOn();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((strcmp(argv[0],<span class="stringliteral">&quot;power&quot;</span>)==0)&amp;&amp;(strcmp(argv[1],<span class="stringliteral">&quot;off&quot;</span>)==0))</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, powerOff, <span class="keyword">sizeof</span>(powerOff), HAL_MAX_DELAY);</div>
<div class="line">        motorPowerOff();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span>{</div>
<div class="line">        shellCmdNotFound();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36"></a>
Test de la fonction</h3>
<p >Pour effectuer le test, nous avons utilisé un oscilloscope en mode single trigger pour mesurer la longeur de l'impulsion:</p>
<p ><img src="./Images/Oscillo_ISO_RESET.png" alt="Oscillo ISO_RESET" title="Impulsion sur ISO_RESET" class="inline"/></p>
<p >Nous observons ici que notre temps mort est de plus de 2us, nous respectons donc le cahier des charges.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Commande setAlpha</h2>
<p >Cette fonction nous permet de régler directement la valeur de alpha entrant dans le commandShell "set alpha " suivi d'un entier compris entre 0 et 100. A l'initialisation alpha vaut 50, ce qui correspond à une vitesse nulle:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setAlpha(<span class="keywordtype">int</span> alpha1)</div>
<div class="line">{</div>
<div class="line">    TIM1-&gt;CCR1=alpha1*(TIM1-&gt;ARR)/100;</div>
<div class="line">    TIM1-&gt;CCR2=(100-alpha1)*(TIM1-&gt;ARR)/100;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Cette foonction est l'une des plus importante de notre code, elle est utilisée à la fin de notre boucle d'asservissement pour régler le alpha.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Capteur de courant et position</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Mesure de courant</h2>
<p >Pour mesurer le courant nous allons utiliser un ADC en mode DMA qui sera connecté a un des capteurs à effet Hall présent sur le hacheur. L'ADC sera cadencé par le Timer 2 qui aura une fréquence de 160kHz. Le DMA remplira un Buffer de 10 valeur et nous ferons la moyenne du courant sur ces 10 valeurs pour avoir notre courant moyen. Cette démarche évite de prendre une mesure de courant erronées, car le courant passant dans le moteur comporte de très grandes variations ,et celles-ci peuvent nous géner lors de notre asservissement.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
Paramètres ADC</h3>
<p ><img src="./Images/ADC_param.png" alt="ADC setting1" title="Paramètres de l&apos;ADC" class="inline"/> <img src="./Images/ADC_param1.png" alt="ADC setting2" title="Paramètres de l&apos;ADC" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md41"></a>
Fonctions liées à l'ADC</h3>
<p >Pour se servir de l'ADC en mode DMA, il faut récuperer la fonction HAL_ADC_ConvCpltCallback. Cette fonction met un flag à 1 quand le buffer de l'ADC est rempli:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="adc_8h.html#af20a88180db1113be1e89266917d148b">HAL_ADC_ConvCpltCallback</a>(<a class="code hl_struct" href="struct_a_d_c___handle_type_def.html">ADC_HandleTypeDef</a> *hadc)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (hadc == &amp;hadc1)</div>
<div class="line">  {</div>
<div class="line">      adcDMAflag=1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aadc_8h_html_af20a88180db1113be1e89266917d148b"><div class="ttname"><a href="adc_8h.html#af20a88180db1113be1e89266917d148b">HAL_ADC_ConvCpltCallback</a></div><div class="ttdeci">void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)</div><div class="ttdef"><b>Definition:</b> adc.c:191</div></div>
<div class="ttc" id="astruct_a_d_c___handle_type_def_html"><div class="ttname"><a href="struct_a_d_c___handle_type_def.html">ADC_HandleTypeDef</a></div><div class="ttdoc">ADC handle Structure definition.</div><div class="ttdef"><b>Definition:</b> stm32g4xx_hal_adc.h:387</div></div>
</div><!-- fragment --><p >Nous avons ensuite codé une fonction qui calcule la moyenne des 10 valeurs présentes dans le buffer pré-rempli par le DMA:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="adc_8h.html#a47bb0c342c4c56e23074031f2c3c51a1">meanADCValue</a> (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">int</span> sum=0;</div>
<div class="line">    <span class="keywordflow">if</span> (adcDMAflag==1)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (i=0; i&lt;ADC_HALL_BUFFER; i=i+1)</div>
<div class="line">        {</div>
<div class="line">            sum=sum+ adcBuffer[i];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        hallVoltageValue= ((sum/ADC_HALL_BUFFER)*3.3/4096.0)+OFFSET_DEFAULT_ADC;</div>
<div class="line">        hallCurrentValue= (hallVoltageValue-VOLTAGE_HALL_OC)*HALL_GAIN;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aadc_8h_html_a47bb0c342c4c56e23074031f2c3c51a1"><div class="ttname"><a href="adc_8h.html#a47bb0c342c4c56e23074031f2c3c51a1">meanADCValue</a></div><div class="ttdeci">void meanADCValue(void)</div><div class="ttdoc">Make the mean of the current value stocked in the buffer and stock it in the hallCurrentValue variabl...</div><div class="ttdef"><b>Definition:</b> adc.c:204</div></div>
</div><!-- fragment --><p >Nous avons aussi codé une fonction nous permettons d'afficher la valeur du courant sur le commandShell grâce à la commande "measure current":</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="usart_8h.html#a87d18aaef58c13918534ec7ede396b15">uartPrintADCValue</a>(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="adc_8h.html#a47bb0c342c4c56e23074031f2c3c51a1">meanADCValue</a>();</div>
<div class="line">    sprintf(uartTxBuffer,<span class="stringliteral">&quot;Current: %.2f A\r\n&quot;</span>,hallCurrentValue);</div>
<div class="line">    HAL_UART_Transmit(&amp;huart2, uartTxBuffer, <span class="keyword">sizeof</span>(uartTxBuffer), HAL_MAX_DELAY);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="ausart_8h_html_a87d18aaef58c13918534ec7ede396b15"><div class="ttname"><a href="usart_8h.html#a87d18aaef58c13918534ec7ede396b15">uartPrintADCValue</a></div><div class="ttdeci">void uartPrintADCValue(void)</div><div class="ttdoc">Allow to display the current value of the motor using the USART bus.</div><div class="ttdef"><b>Definition:</b> usart.c:169</div></div>
</div><!-- fragment --><p> Le commandShell a été modifié pour interpréter la commande "measure Current" et lancer la fonction uartPrintADCValue.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Mesure de Vitesse</h2>
<p >Pour mesurer la vitesse, nous allons utiliser les roues codeuses présentent sur les MCC, Il y'as 2 roues de 1024 segments, nous allons compter les fronts montants et déscendants, nous avons donc 4096 points sur un tour.</p>
<p >Nous allons utiliser le Timer3 en mode counter pour compter les incréments sur les roues codeuses. Nous utiliserons le Timer5 pour venir récupérer la valeur du codeur à une fréquence de 10Hz</p>
<p >Nous devons penser à initialiser le compteur de TIM3 à son point milieu pour éviter que la vitesse fasse un bond si le moteur passe en marche arrière ce qui ferai passer le compteur de 0 a 65535.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
Paramètres des Timers</h3>
<h4><a class="anchor" id="autotoc_md44"></a>
Timer 3: Mode Counter</h4>
<p ><img src="./Images/TIM3_param.png" alt="Counter setting" title="TIM3 setting" class="inline"/></p>
<h4><a class="anchor" id="autotoc_md45"></a>
Timer 5: Mode Interruption</h4>
<p ><img src="./Images/TIM5_param.png" alt="Counter setting" title="TIM5 setting" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md46"></a>
Fonctions de calcul de la vitesse</h3>
<p >Nous devons d'abord traiter l'interruption envoyée par TIM5, nous utlisons pour cela la fonction HAL_TIM_PeriodElapsedCallBack: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group___t_i_m___exported___functions___group9.html#ga8a3b0ad512a6e6c6157440b68d395eac">HAL_TIM_PeriodElapsedCallback</a>(<a class="code hl_struct" href="struct_t_i_m___handle_type_def.html">TIM_HandleTypeDef</a> *htim)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* USER CODE BEGIN Callback 0 */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* USER CODE END Callback 0 */</span></div>
<div class="line">    <span class="keywordflow">if</span> (htim-&gt;<a class="code hl_variable" href="struct_t_i_m___handle_type_def.html#ad0c5f736a15f6d8d14724854c8133bcc">Instance</a> == TIM6) {</div>
<div class="line">        HAL_IncTick();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* USER CODE BEGIN Callback 1 */</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (htim-&gt;<a class="code hl_variable" href="struct_t_i_m___handle_type_def.html#ad0c5f736a15f6d8d14724854c8133bcc">Instance</a> == TIM5){</div>
<div class="line">        codeurValue= TIM3-&gt;CNT;</div>
<div class="line">        TIM3-&gt;CNT = TIM3-&gt;ARR/2;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* USER CODE END Callback 1 */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup___t_i_m___exported___functions___group9_html_ga8a3b0ad512a6e6c6157440b68d395eac"><div class="ttname"><a href="group___t_i_m___exported___functions___group9.html#ga8a3b0ad512a6e6c6157440b68d395eac">HAL_TIM_PeriodElapsedCallback</a></div><div class="ttdeci">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</div><div class="ttdoc">Period elapsed callback in non blocking mode.</div><div class="ttdef"><b>Definition:</b> main.c:259</div></div>
<div class="ttc" id="astruct_t_i_m___handle_type_def_html"><div class="ttname"><a href="struct_t_i_m___handle_type_def.html">TIM_HandleTypeDef</a></div><div class="ttdoc">TIM Time Base Handle Structure definition.</div><div class="ttdef"><b>Definition:</b> stm32g4xx_hal_tim.h:365</div></div>
<div class="ttc" id="astruct_t_i_m___handle_type_def_html_ad0c5f736a15f6d8d14724854c8133bcc"><div class="ttname"><a href="struct_t_i_m___handle_type_def.html#ad0c5f736a15f6d8d14724854c8133bcc">TIM_HandleTypeDef::Instance</a></div><div class="ttdeci">TIM_TypeDef * Instance</div><div class="ttdef"><b>Definition:</b> stm32g4xx_hal_tim.h:366</div></div>
</div><!-- fragment --><p> Dans cette fonction nous recuperons la valeur du compteur de TIM3 et nous le remettons à son point milieu pour la prochaine mesure.</p>
<p >Nous devons maintenant calculer la vitesse a partir des valeurs mesurées, pour se faire nous avons créé la fonction calcSpeed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> calcSpeed (<span class="keywordtype">void</span>){</div>
<div class="line">    speed=(codeurValue-((TIM3-&gt;ARR)/2.0))*FREQ_ECH_SPEED*60.0/NUMBER_OF_POINT;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Nous avons aussi une fonction qui nous permet d'afficher la vitesse sur le commandSheel quand on entre "measure speed":</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="usart_8h.html#abe00133db62c3ee3b002d03e9c61bcda">uartPrintSpeed</a>(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    calcSpeed();</div>
<div class="line">    sprintf(uartTxBuffer,<span class="stringliteral">&quot;Speed: %.2f tr/min\r\n&quot;</span>,speed);</div>
<div class="line">    HAL_UART_Transmit(&amp;huart2, uartTxBuffer, <span class="keyword">sizeof</span>(uartTxBuffer), HAL_MAX_DELAY);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="ausart_8h_html_abe00133db62c3ee3b002d03e9c61bcda"><div class="ttname"><a href="usart_8h.html#abe00133db62c3ee3b002d03e9c61bcda">uartPrintSpeed</a></div><div class="ttdeci">void uartPrintSpeed(void)</div><div class="ttdoc">Allow to display the speed value of the motor using the USART bus.</div><div class="ttdef"><b>Definition:</b> usart.c:180</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md47"></a>
Asservissement</h1>
<p >Maintenant que nous reussissons a mesure le courant et la vitesse, nous allons effectuer un asservissement en courant puis en vitesse.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Asservissement en courant</h2>
<p >Nous allons utiliser une régulation PI parrallèle pour mettre en place notre asservissement en courant. Pour se faire, nous devons calculer notre commande selon le gain proportionnel et notre commande selon le gain intégral. Nous devons veiller a ce que notre commande ne dépasse pas 1 et que l'intégrale prenne en compte l'anti-windup.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> asserCurrent (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="adc_8h.html#a47bb0c342c4c56e23074031f2c3c51a1">meanADCValue</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> eps= consignCurrent - hallCurrentValue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Proportional part</span></div>
<div class="line">    <span class="keywordflow">if</span> (Kp*eps &lt; 0){</div>
<div class="line">        alphaKp=0.0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Kp*eps &gt; 1) {</div>
<div class="line">        alphaKp=1.0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        alphaKp=eps*(float)Kp;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Integral part</span></div>
<div class="line"> </div>
<div class="line">    alphaKi=alphaKiOld+((Ki*Te)/2)*(eps+epsOld);</div>
<div class="line">    <span class="keywordflow">if</span> (alphaKi &lt; 0){</div>
<div class="line">        alphaKi=0.0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alphaKi &gt; 1) {</div>
<div class="line">        alphaKi=1.0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    alphaKiOld=alphaKi;</div>
<div class="line">    epsOld=eps;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Summ of the two coeff</span></div>
<div class="line"> </div>
<div class="line">    alpha=(int)((alphaKi+alphaKp)*100);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (alpha &lt; 0){</div>
<div class="line">        alpha=0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alpha &gt; 100) {</div>
<div class="line">        alpha=100;</div>
<div class="line">    }</div>
<div class="line">    setAlpha(alpha);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> Nous devons aussi modifier certaines autres fonctions pour que notre asservissement ne démarre pas avant que la fonction motorPowerOn soit enclenché, on ajoute donc un startFlag qui permet de démarrer notre asservissement.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> motorPowerOn(<span class="keywordtype">void</span>){</div>
<div class="line">    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); <span class="comment">// just for test, you can delete it</span></div>
<div class="line">    <span class="comment">//Phase de démarage//</span></div>
<div class="line">    HAL_GPIO_WritePin(ISO_RESET_GPIO_Port, ISO_RESET_Pin,GPIO_PIN_SET );</div>
<div class="line">    setAlpha(50);</div>
<div class="line">    HAL_TIM_PWM_Start(&amp;htim1,<a class="code hl_define" href="group___t_i_m___channel.html#ga6b1541e4a49d62610899e24bf23f4879">TIM_CHANNEL_1</a> );</div>
<div class="line">    HAL_TIMEx_PWMN_Start(&amp;htim1, <a class="code hl_define" href="group___t_i_m___channel.html#ga6b1541e4a49d62610899e24bf23f4879">TIM_CHANNEL_1</a>);</div>
<div class="line">    HAL_TIM_PWM_Start(&amp;htim1,<a class="code hl_define" href="group___t_i_m___channel.html#ga33e02d43345a7ac5886f01b39e4f7ccd">TIM_CHANNEL_2</a> );</div>
<div class="line">    HAL_TIMEx_PWMN_Start(&amp;htim1, <a class="code hl_define" href="group___t_i_m___channel.html#ga33e02d43345a7ac5886f01b39e4f7ccd">TIM_CHANNEL_2</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> i=0;</div>
<div class="line">    <span class="keywordflow">while</span> (i&lt;33)</div>
<div class="line">    {</div>
<div class="line">        i++;</div>
<div class="line">    }</div>
<div class="line">    HAL_GPIO_WritePin(ISO_RESET_GPIO_Port, ISO_RESET_Pin, GPIO_PIN_RESET);</div>
<div class="line"> </div>
<div class="line">    consignCurrent=0;</div>
<div class="line">    startFlag=1;</div>
<div class="line">    alphaKiOld=0.5;</div>
<div class="line">    epsOld=0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> Quand le startflag est à 1, nous passons par la fonction asserCurrent dans notre Superloop.</p>
<p >Il a fallu aussi ajouter un commande au Shell pour pouvoir entre la valeur de courant souhaité, voici notre nouvelle fonction shellExec:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> shellExec(<span class="keywordtype">void</span>){</div>
<div class="line">    <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;set&quot;</span>)==0){</div>
<div class="line">        <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;PA5&quot;</span>)==0 &amp;&amp; ((strcmp(argv[2],<span class="stringliteral">&quot;0&quot;</span>)==0)||(strcmp(argv[2],<span class="stringliteral">&quot;1&quot;</span>)==0)) ){</div>
<div class="line">            HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, atoi(argv[2]));</div>
<div class="line">            stringSize = snprintf((<span class="keywordtype">char</span>*)uartTxBuffer,UART_TX_BUFFER_SIZE,<span class="stringliteral">&quot;Switch on/off led : %d\r\n&quot;</span>,atoi(argv[2]));</div>
<div class="line">            HAL_UART_Transmit(&amp;huart2, uartTxBuffer, stringSize, HAL_MAX_DELAY);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;speed&quot;</span>)==0){</div>
<div class="line">            <span class="keywordflow">if</span>(atoi(argv[2])==0 &amp;&amp; strcmp(argv[2],<span class="stringliteral">&quot;0&quot;</span>)!=0){</div>
<div class="line">                HAL_UART_Transmit(&amp;huart2, motorSpeedInst, <span class="keyword">sizeof</span>(motorSpeedInst), HAL_MAX_DELAY);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span>{</div>
<div class="line">                motorSetSpeed(atoi(argv[2]));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;alpha&quot;</span>)==0){</div>
<div class="line">            setAlpha(atoi(argv[2]));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;current&quot;</span>)==0){</div>
<div class="line">                    consignCurrent=(atof(argv[2]));</div>
<div class="line"> </div>
<div class="line">                }</div>
<div class="line">        <span class="keywordflow">else</span>{</div>
<div class="line">            shellCmdNotFound();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(argv[0],<span class="stringliteral">&quot;measure&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;current&quot;</span>)==0){</div>
<div class="line">            <a class="code hl_function" href="usart_8h.html#a87d18aaef58c13918534ec7ede396b15">uartPrintADCValue</a>();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(argv[1],<span class="stringliteral">&quot;speed&quot;</span>)==0){</div>
<div class="line">            <a class="code hl_function" href="usart_8h.html#abe00133db62c3ee3b002d03e9c61bcda">uartPrintSpeed</a>();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;help&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, help, <span class="keyword">sizeof</span>(help), HAL_MAX_DELAY);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;pinout&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, pinout, <span class="keyword">sizeof</span>(pinout), HAL_MAX_DELAY);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((strcmp(argv[0],<span class="stringliteral">&quot;power&quot;</span>)==0)&amp;&amp;(strcmp(argv[1],<span class="stringliteral">&quot;on&quot;</span>)==0))</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, powerOn, <span class="keyword">sizeof</span>(powerOn), HAL_MAX_DELAY);</div>
<div class="line">        motorPowerOn();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((strcmp(argv[0],<span class="stringliteral">&quot;power&quot;</span>)==0)&amp;&amp;(strcmp(argv[1],<span class="stringliteral">&quot;off&quot;</span>)==0))</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, powerOff, <span class="keyword">sizeof</span>(powerOff), HAL_MAX_DELAY);</div>
<div class="line">        motorPowerOff();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span>{</div>
<div class="line">        shellCmdNotFound();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Avec cette modification, nous pouvons régler le courant souhaité via la commande set current suivit de la valeur de type float souhaitée.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Asservissement de Vitesse</h2>
<p >Nous allons utiliser une régulation PI parrallèle pour mettre en place notre asservissement en vitesse. Pour se faire, nous devons calculer notre courant de référence selon le gain proportionnel et notre courant de référence selon le gain intégral. Nous devons veiller a ce que notre courant de référence ne dépasse pas 7A et que l'intégrale prenne en compte l'anti-windup.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> asserSpeed (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    calcSpeed();</div>
<div class="line">    <span class="keywordtype">float</span> eps= consignSpeed - speed;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Proportional part</span></div>
<div class="line">    <span class="keywordflow">if</span> (KpSpeed*eps &lt; -IMAX){</div>
<div class="line">        currentKp=-IMAX;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (KpSpeed*eps &gt; IMAX) {</div>
<div class="line">        currentKp=IMAX;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        currentKp=eps*(float)KpSpeed;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Integral part</span></div>
<div class="line"> </div>
<div class="line">    currentKi=currentKiOld+((KiSpeed*TeSpeed)/2)*(eps+speedEpsOld);</div>
<div class="line">    <span class="keywordflow">if</span> (currentKi &lt; -IMAX){</div>
<div class="line">        currentKi=-IMAX;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentKi &gt; IMAX) {</div>
<div class="line">        currentKi=IMAX;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    currentKiOld=currentKi;</div>
<div class="line">    speedEpsOld=eps;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Summ of the two coeff</span></div>
<div class="line"> </div>
<div class="line">    consignCurrent=(float)(currentKi+currentKp);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (consignCurrent &lt; -IMAX){</div>
<div class="line">        consignCurrent=-IMAX;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (consignCurrent &gt; IMAX) {</div>
<div class="line">        consignCurrent=IMAX;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Nous avons ensuite modifié le Shell pour pouvoir choisir entre l'asservissement en courant ou en vitesse grâce à la commande "mode [int]" avec 1 pour un asservissement en courant et 2 pour un asservissement en tension.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> shellExec(<span class="keywordtype">void</span>){</div>
<div class="line">    <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;set&quot;</span>)==0){</div>
<div class="line">        <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;PA5&quot;</span>)==0 &amp;&amp; ((strcmp(argv[2],<span class="stringliteral">&quot;0&quot;</span>)==0)||(strcmp(argv[2],<span class="stringliteral">&quot;1&quot;</span>)==0)) ){</div>
<div class="line">            HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, atoi(argv[2]));</div>
<div class="line">            stringSize = snprintf((<span class="keywordtype">char</span>*)uartTxBuffer,UART_TX_BUFFER_SIZE,<span class="stringliteral">&quot;Switch on/off led : %d\r\n&quot;</span>,atoi(argv[2]));</div>
<div class="line">            HAL_UART_Transmit(&amp;huart2, uartTxBuffer, stringSize, HAL_MAX_DELAY);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;speed&quot;</span>)==0){</div>
<div class="line">            consignSpeed= (atof(argv[2]));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;alpha&quot;</span>)==0){</div>
<div class="line">            setAlpha(atoi(argv[2]));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;current&quot;</span>)==0){</div>
<div class="line">            consignCurrent=(atof(argv[2]));</div>
<div class="line"> </div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span>{</div>
<div class="line">            shellCmdNotFound();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(argv[0],<span class="stringliteral">&quot;measure&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(strcmp(argv[1],<span class="stringliteral">&quot;current&quot;</span>)==0){</div>
<div class="line">            <a class="code hl_function" href="usart_8h.html#a87d18aaef58c13918534ec7ede396b15">uartPrintADCValue</a>();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(argv[1],<span class="stringliteral">&quot;speed&quot;</span>)==0){</div>
<div class="line">            <a class="code hl_function" href="usart_8h.html#abe00133db62c3ee3b002d03e9c61bcda">uartPrintSpeed</a>();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(argv[0],<span class="stringliteral">&quot;mode&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        chooseModeFlag= atoi(argv[1]);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;help&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, help, <span class="keyword">sizeof</span>(help), HAL_MAX_DELAY);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(strcmp(argv[0],<span class="stringliteral">&quot;pinout&quot;</span>)==0)</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, pinout, <span class="keyword">sizeof</span>(pinout), HAL_MAX_DELAY);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((strcmp(argv[0],<span class="stringliteral">&quot;power&quot;</span>)==0)&amp;&amp;(strcmp(argv[1],<span class="stringliteral">&quot;on&quot;</span>)==0))</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, powerOn, <span class="keyword">sizeof</span>(powerOn), HAL_MAX_DELAY);</div>
<div class="line">        motorPowerOn();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((strcmp(argv[0],<span class="stringliteral">&quot;power&quot;</span>)==0)&amp;&amp;(strcmp(argv[1],<span class="stringliteral">&quot;off&quot;</span>)==0))</div>
<div class="line">    {</div>
<div class="line">        HAL_UART_Transmit(&amp;huart2, powerOff, <span class="keyword">sizeof</span>(powerOff), HAL_MAX_DELAY);</div>
<div class="line">        motorPowerOff();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span>{</div>
<div class="line">        shellCmdNotFound();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Nous avons ensuite ajouté un flage qui se positionne à 1 quand on entre dans l'interruption du TIM5 afin de cadencer notre asservissement de vitesse à 10Hz.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group___t_i_m___exported___functions___group9.html#ga8a3b0ad512a6e6c6157440b68d395eac">HAL_TIM_PeriodElapsedCallback</a>(<a class="code hl_struct" href="struct_t_i_m___handle_type_def.html">TIM_HandleTypeDef</a> *htim)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* USER CODE BEGIN Callback 0 */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* USER CODE END Callback 0 */</span></div>
<div class="line">    <span class="keywordflow">if</span> (htim-&gt;<a class="code hl_variable" href="struct_t_i_m___handle_type_def.html#ad0c5f736a15f6d8d14724854c8133bcc">Instance</a> == TIM6) {</div>
<div class="line">        HAL_IncTick();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* USER CODE BEGIN Callback 1 */</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (htim-&gt;<a class="code hl_variable" href="struct_t_i_m___handle_type_def.html#ad0c5f736a15f6d8d14724854c8133bcc">Instance</a> == TIM5){</div>
<div class="line">        codeurValue= TIM3-&gt;CNT;</div>
<div class="line">        TIM3-&gt;CNT = TIM3-&gt;ARR/2;</div>
<div class="line">        speedFlag=1;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* USER CODE END Callback 1 */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Notre super loop finale qui nous permet de lancer nos asservissement est la suivante: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// SuperLoop inside the while(1), only flag changed from interrupt could launch functions</span></div>
<div class="line">    <span class="keywordflow">if</span>(uartRxReceived){</div>
<div class="line">        <span class="keywordflow">if</span>(shellGetChar()){</div>
<div class="line">            shellExec();</div>
<div class="line">            shellPrompt();</div>
<div class="line">        }</div>
<div class="line">        uartRxReceived = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">switch</span> (chooseModeFlag){</div>
<div class="line">    <span class="keywordflow">case</span> 1:</div>
<div class="line">        <span class="keywordflow">if</span> (adcDMAflag)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (startFlag){</div>
<div class="line">                asserCurrent();</div>
<div class="line">            adcDMAflag=0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 2:</div>
<div class="line">        <span class="keywordflow">if</span> (adcDMAflag)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (startFlag){</div>
<div class="line">                asserCurrent();</div>
<div class="line">            }</div>
<div class="line">            adcDMAflag=0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (speedFlag)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (startFlag){</div>
<div class="line">                asserSpeed();</div>
<div class="line">            }</div>
<div class="line">            speedFlag=0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
</div><!-- fragment --><p >Nous avons tracé la réponse en courant et en vitesse à un échelon de 1500tr/min:</p>
<p ><img src="./Images/Réponse_echelon_vitesse.png" alt="Step_Response_Speed" title="Réponse à un échelon de vitesse" class="inline"/></p>
<p >Observations: On peut voir ici que au démarage notre courant est bien saturé a IMAX pce qui nous permet d' avoir une accélération constante et une fois proche de notre vitesse de consigne, le courant baisse afin de stabiliser la vitesse a 1500 tr/min.</p>
<h1><a class="anchor" id="autotoc_md50"></a>
Commande de Test</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
Test Asservissemment Courant:</h2>
<p >Commandes à lancer:</p>
<ul>
<li>power on</li>
<li>mode 1</li>
<li>set current [float]</li>
</ul>
<h2><a class="anchor" id="autotoc_md52"></a>
Test Asservissement Vitesse :</h2>
<p >Commandes à lancer:</p>
<ul>
<li>power on</li>
<li>mode 2</li>
<li>set speed [float]</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Test set Alpha:</h2>
<p >Commande à lancer:</p>
<ul>
<li>power on</li>
<li>set alpha [int]</li>
</ul>
<h1><a class="anchor" id="autotoc_md54"></a>
Author</h1>
<ul>
<li><a href="https://github.com/ErwanBrochot/">@Erwan Brochot</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
